# No Password

**No Password** is a password management tool that does not need to store passwords in a *vault*, like other password managers.  No Password can be thought of as a *password generation tool*.  It only stores the *metadata* required to generate a password for a service (such as a website or application) - the user still needs to combine it with an underlying password - unstored - to generate that service-specific password.  However, this can be a single, reusable password.

The metadata it stores is linked to the restrictions associated with that service.  For example:

- A website may require passwords have a maximum length.  No Password shrinks generated passwords to fit this.
- A website may require passwords to have symbols in them.  No Password will replace certain characters with symbols on a consistent basis.

The main benefit of this scheme is that it lacks a single-point of failure (the vault itself).  If any of the files created by No Password are stolen, they lack any information about the user's underlying password.  This means (if strongly discouraged) that you can, in theory, reuse the metadata for many underlying passwords - this is because the metadata is entirely independent of the user password.

## Disclaimers

- The author of this project is not a cryptographer.
- The code itself is likely not bulletproof.  Other password managers on the market have had penetration testing and vulnerability testing; this project has not.
- This is a toy project of sorts for the author, who has had this idea for a while but only has had time to work on this due to being made redundant.
- The author doesn't recommend you use this, but use it as a thought exercise.  As such, use it at your own risk.
- The author makes no money off this code, so cannot offer bug bounties for it.  Security fixes are welcome through issues or pull requests.

## Explanation

Compared with other password managers on the market, its risk profile is slightly different - it trades *per-service security* - for example, your password for your Gmail account as stored by Google - for a lack of a single point of failure.

If a user uses no password manager, this is how passwords are stored:

![Not using a password manager](https://raw.githubusercontent.com/x42bn6/no-password-java/master/readme/No%20password%20manager.png)

A user reuses a password ("Password") for all their services.  Each service stores passwords slightly-differently - good services will use a strong cryptographic algorithm, such as [scrypt](https://en.wikipedia.org/wiki/Scrypt); other, more-dubious services may store it in plaintext (strongly not recommended).

If an attacker compromises a certain service, such as the dubious one above, this in effect reveals all passwords for all services, since the original password "Password" can be reverse-engineered:

![Not using a password manager - compromised](https://raw.githubusercontent.com/x42bn6/no-password-java/master/readme/No%20password%20manager%20(compromised).png)

Existing password managers on the market mitigate this risk.  They generate very strong, effectively-random strings, per service, and store them in a vault.  This vault is encrypted by a master password.

![Other password managers](https://raw.githubusercontent.com/x42bn6/no-password-java/master/readme/Other%20password%20managers.png)

Because each per-service password is a random string, there is no linkage between each generated password.  Compromising one website reveals no information about the underlying password, nor any other stored password on another service.

However, this carries the drawback of having all your passwords stored in a vault.  If a user's master password is weak, this vault can be compromised, revealing all passwords for all services.

No Password does this differently.

![No Password](https://raw.githubusercontent.com/x42bn6/no-password-java/master/readme/No%20password.png)

No Password takes a user password (not stored) and uses this to generate a per-service password, only storing the metadata required to generate the password.  If a user needs to generate a password again (for example, they log out and need to log in again), the user must regenerate the password by entering their underlying password again.

The generated passwords are not quite random strings like other password managers - they are all linked by the same underlying password, with different cryptographic salts.  This, along with other attacks (see below), means that these passwords are not as strong as those generated by other password managers - but no passwords are stored on a user's system.

This is a tradeoff that users should consider.

## Other weaknesses with this scheme

### Double-hashing weakens password security

There are multiple attacks associated with double-hashing, but I'll describe one simple one below: Collisions.

Every hashing algorithm, no matter how strong, has collisions.  Collisions are where two or more different inputs result in the same hashed output.  Say my hash function is *f* and I have two inputs, *ABC* and *DEF*:

![](https://render.githubusercontent.com/render/math?math=f(ABC)%3Df(DEF)%3D123&mode=inline)

In other words, *ABC* and *DEF* collide with each other.

If we double-hash, both hashing processes will have collisions.  Let's say that:

![](https://render.githubusercontent.com/render/math?math=f(f(ABC))%3Df(f(DEF))%3Df(123)%3D789&mode=inline)

and:

![](https://render.githubusercontent.com/render/math?math=f(f(GHI))%3Df(f(JKL))%3Df(456)%3D789&mode=inline)

In other words, under *f*, these collisions exist:

- *ABC* and *DEF*
- *GHI* and *JKL*
- *123* and *456*

Thus by double-hashing, we have *doubled* the number of effective collisions.  If your underlying password is *ABC*, an attacker can also use *DEF*, *GHI* and *JKL* to access your account on a service.

This is also a simplification of sorts - there are likely more than two collisions under scrypt (if the input size is limited).

[This page](https://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once) has more ideas.

There are secure ways to hash multiple times - such as [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2).  However, this is useless here, as we have no control over what a service such as Google does.

### Copying to clipboard

Other password managers have schemes to automatically autofill passwords through, say, browser plugins.  No plugins have been written for No Password, which settles on copying the password to the clipboard, and clearing it after a configurable number of seconds.  This inevitably leaks the information for other processes to steal.

## Licensing

[![License: CC BY 4.0](https://licensebuttons.net/l/by/4.0/80x15.png)](https://creativecommons.org/licenses/by/4.0/)

This code is licensed under Attribution 4.0 International (CC BY 4.0) ([](https://creativecommons.org/licenses/by/4.0/).
